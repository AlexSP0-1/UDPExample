## Описание решения тестовой задачи.

Для решения задачи, был выбран фреймворк Qt5 в целях ускорения решения задачи, а именно: использование встроенного парсера командной строки, использование сетевой части фреймворка, использование строковых возможностей и кодировки строк.

Решение состоит из трех компонент: **клиента**, **сервера**, а также **общей библиотеки** для парсинга и создания сообщений для обмена. Общая библиотека - статическая.

**Сервер**. Сервер архитектурно состоит из парсера командной строки, хранилища и части, ответственной за прием запросов и формирование ответов. Парсер командной строки взят из фреймворка Qt5.  
Хранилище реализует интерфейс UDPServerStorageInterface для быстрой замены реализации на другую. Реализована лишь реализация чтения данных из файла. Все ресурсы хранятся в оперативной памяти, для обновления их файла реализован метод update(). Так как большая часть операций с хранилищем должна быть на чтение(по задаче), то для оптимизации многопоточного чтения из хранилища, а также безопасного обновления из файла, применяются std::shared_mutex.
Обработка запросов и отправка ответа реализована в отдельном потоке с использованием глобального пула потоков QThreadPool фреймворка Qt. Это позволяет не заботиться о времени жизни отдельного потока, так как им управляет QThreadPool. Это удобно, так как никаких специальных тербований в задаче нет. 

**Клиент**. Большая часть кода клиента - парсинг командной строки, лишь небольшая часть - формирование и отправка запроса на сервер, парсинг и печать ответа в консоль.

**Общая библиотека** была реализована для повторного использования кода формирования и парсинга сообщений. Сначала хотел реализовать фабрику для создания парсеров для выбранного типа сообщений, но, решил, что это излишне, остался только интерфейс для парсеров UDPExampleMessageParserInterface. Длина имени ресурса и значения ресурса могут быть произвольными до uint32_t MAX, хотя в задаче они ограничены до 64 и 1024 байт соотвественно. Однако, отправлять сообщения более MTU не рекомендуется, так как они будут дробиться, а поскольку, проверки целостности не происходит, то возможно искажение и потеря части информации.
